## 課題 1

![image](https://raw.githubusercontent.com/yuikoito/PrAhaChallenge/master/db/db-modeling-3/DB3%20Diagram%20task1.drawio.png)

### 親ディレクトリと小ディレクトリの関係性を表すテーブル（ディレクトリ間中間テーブル）を作らなかった理由

- 親ディレクトリの中に、子ディレクトリと同時にドキュメントも入る可能性がある
- そのため、もし作るのであれば、ドキュメントも子になりうることを考慮する必要がある
- そうするとテーブルとしては、親 ID、子 ID として持ちたいのに、親 ID、子ディレクトリ ID、子ドキュメント ID の３つをもつ事になり、完全な親子テーブルとは言いにくい。もし関係性を表すためだけの子 ID をドキュメント、ディレクトリそれぞれに発行して使うのなら可能だが、その場合発行された子 ID と自身の ID が衝突しないようにする必要があり、整合性を保つために労力がかかる。
- また、ドキュメントとディレクトリの構成が似ているため、インターフェースを似せておくことで、同じ検索クエリを使うことが出来て楽。もしディレクトリだけに中間テーブルを用意すると検索方法が変わるので、実装にも時間がかかる。


### 9/2追記　閉包テーブルの方が良いと思ったので書き換えました。

- 参考: https://kentama.hatenablog.com/entry/2016/07/30/221603
- 親ディレクトリの中に、子ディレクトリと同時にドキュメントも入る可能性があるに関してはそもそも親ディレクトリと子ディレクトリの関係性のみを持つ閉包テーブルという風にしてしまえば問題ないことに気が付きました。

## 課題 2

![image](https://raw.githubusercontent.com/yuikoito/PrAhaChallenge/master/db/db-modeling-3/DB3%20Diagram%20task2.drawio.png)

ドキュメントテーブルに直前直後のドキュメント ID を保持するように変更した

### ドキュメントテーブルに順番（Index）を持たない理由

- 例えば、特定のディレクトリ内に 1000 件のドキュメントがあり、1000 番目のドキュメントを 1 番上に持ってきた場合、全レコードの Index を書き換える必要が出てきてしまう。

```
（イメージ）
1 番目 → 2 番目
2 番目 → 3 番目
3 番目 → 4 番目
4 番目 → 5 番目
5 番目 → 6 番目
...
999 番目 → 1000 番目
1000 番目 → 1 番目
```

### 直前直後のドキュメント ID 両方を保持する理由

- 1 番目から順番に並び替えを行う場合、直前のドキュメント ID が null のものが一番目、そのレコードが持っている直後のドキュメント ID が二番目、という風に順番に並び替えを行うことができる。
- もし直前・直後の片方しか持たない場合、並び替え自体は可能だが、逆引き（例えば直前のみの場合、直前のドキュメント ID が null のものが一番目、そのドキュメント ID を直前のドキュメント ID に持つレコードを探す）をしないといけないので、計算コストがかかる。
- 直前・直後両方のドキュメント ID を保持することで、順引きができるようになるので、計算コスト削減に役立つ。

### 直前直後のドキュメント ID を使った並び替え方法

![image](https://raw.githubusercontent.com/yuikoito/PrAhaChallenge/master/db/db-modeling-3/DB3%20Diagram%20task2-example.drawio.png)

## food for thought

- notion のテーブルで確認した

https://user-images.githubusercontent.com/43722788/186717932-7e16968d-f7ae-4dd8-90a4-982e2f70587d.mov

ページ（ID: dea24fcf-...）に存在するカード（ID: aeff1eb5-...）を動かした場合、ページ ID（dea24fcf-...）に対してリクエストが送られる

![スクリーンショット 2022-08-26 0 59 59](https://user-images.githubusercontent.com/43722788/186717832-84b2e760-4c46-4699-a507-d5e9772a3c7e.png)


リクエスト内容を詳しく見ると、operations という以下の 5 つパラメータが存在する


- カード（ID: aeff1eb5-...）に対して update をかける宣言
![スクリーンショット 2022-08-26 1 02 47](https://user-images.githubusercontent.com/43722788/186717727-6b32a24d-0eb0-4743-8c1e-b6ec023fec26.png)

- そのカードをどのカテゴリに移動させるかの宣言（ここでは parentId で登録される）
![スクリーンショット 2022-08-26 1 03 39](https://user-images.githubusercontent.com/43722788/186717640-3be5cbbf-6294-483d-898f-d4cc4adefed5.png)

- 順番を入れ替える宣言
![スクリーンショット 2022-08-26 1 07 16](https://user-images.githubusercontent.com/43722788/186717604-1f08bdd1-f346-4252-9d30-b2c991c1435e.png)
  - どのカードの前にまたは後ろに移動させたか
  - 下から上に持っていった場合は listBefore、上から下は listAfter で判別される
  - 以下の場合は、カード（ID: aeff1eb5-...）をカード(ID: ed84c61c-...)の前に持っていくように下から上にドラッグしたということを表す

```
  args: {
    "before": "aeff1eb5-...",
    "id": "ed84c61c-..."
  },
  command: "listBefore"
```

- そのカードの更新日時をアップデートする宣言
![スクリーンショット 2022-08-26 1 13 30](https://user-images.githubusercontent.com/43722788/186717548-c18fb183-6015-432c-953d-93986de651df.png)

- そのカードが属するカテゴリの更新日時をアップデートする宣言
![スクリーンショット 2022-08-26 1 16 04](https://user-images.githubusercontent.com/43722788/186717506-aa07bbec-ce42-4183-8107-4d04b145049e.png)

まとめると、裏でどのような DB を持っているかは正確なことはわからないが、トランザクションを見る限り、直前直後の ID を持っているような感じがした。
