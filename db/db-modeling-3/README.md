## 課題 1

![image](https://raw.githubusercontent.com/yuikoito/PrAhaChallenge/master/db/db-modeling-3/DB3%20Diagram%20task1.drawio.png)

### 親ディレクトリと小ディレクトリの関係性を表すテーブル（ディレクトリ間中間テーブル）を作らなかった理由

- 親ディレクトリの中に、子ディレクトリと同時にドキュメントも入る可能性がある
- そのため、もし作るのであれば、ドキュメントも子になりうることを考慮する必要がある
- そうするとテーブルとしては、親 ID、子 ID として持ちたいのに、親 ID、子ディレクトリ ID、子ドキュメント ID の３つをもつ事になり、完全な親子テーブルとは言いにくい。もし関係性を表すためだけの子 ID をドキュメント、ディレクトリそれぞれに発行して使うのなら可能だが、その場合発行された子 ID と自身の ID が衝突しないようにする必要があり、整合性を保つために労力がかかる。
- また、ドキュメントとディレクトリの構成が似ているため、インターフェースを似せておくことで、同じ検索クエリを使うことが出来て楽。もしディレクトリだけに中間テーブルを用意すると検索方法が変わるので、実装にも時間がかかる。

## 課題 2

![image](https://raw.githubusercontent.com/yuikoito/PrAhaChallenge/master/db/db-modeling-3/DB3%20Diagram%20task2.drawio.png)

ドキュメントテーブルに直前直後のドキュメント ID を保持するように変更した

### ドキュメントテーブルに順番（Index）を持たない理由

- 例えば、特定のディレクトリ内に 1000 件のドキュメントがあり、1000 番目のドキュメントを 1 番上に持ってきた場合、全レコードの Index を書き換える必要が出てきてしまう。

```
（イメージ）
1 番目 → 2 番目
2 番目 → 3 番目
3 番目 → 4 番目
4 番目 → 5 番目
5 番目 → 6 番目
...
999 番目 → 1000 番目
1000 番目 → 1 番目
```

### 直前直後のドキュメント ID 両方を保持する理由

- 1 番目から順番に並び替えを行う場合、直前のドキュメント ID が null のものが一番目、そのレコードが持っている直後のドキュメント ID が二番目、という風に順番に並び替えを行うことができる。
- もし直前・直後の片方しか持たない場合、並び替え自体は可能だが、逆引き（例えば直前のみの場合、直前のドキュメント ID が null のものが一番目、そのドキュメント ID を直前のドキュメント ID に持つレコードを探す）をしないといけないので、計算コストがかかる。
- 直前・直後両方のドキュメント ID を保持することで、順引きができるようになるので、計算コスト削減に役立つ。

### 直前直後のドキュメント ID を使った並び替え方法

![image](https://raw.githubusercontent.com/yuikoito/PrAhaChallenge/master/db/db-modeling-3/DB3%20Diagram%20task2-example.drawio.png)
